---
layout: post
title:  "Coding != Computer Science"
date:   2014-07-03
categories: Bitmaker
permalink: coding-does-not-equal-computer-science
<!-- description: "Week 1 at Bitmaker Labs." -->

comments: true
share: true
---

DRAFT!

My experience at Bitmaker Labs thus far has been an exciting one. The work is challenging, but the program serves as a daily reminder that hard work is its own reward. One of the best features of the program is that——in addition to the fantastic group of instructors we have the pleasure of learning from——my peers are equally interesting and dynamic. There are Bitmakers with engineering and chemistry backgrounds, current computer science students, former marketers and, most notably, two exceptional high school students who've more than managed to teach their older classmates a thing or two. There are international students from Ukraine, the United States, Australia and France. The other day I took off my headphones only to overhear 16-year-old classmate Kash explaining a complex programming concept to a classmate from Paris... in flawless French. This is a pretty incredible place, I thought to myself, before .

Each of my fellow classmates' paths to Bitmaker, when taken altogether, belie a broader gravitational pull toward the tech industry. As a student with a liberal arts background, however, I seem to be in the minority, perhaps unsurprisingly. I've had a few friends and classmates inquire about my motivations in joining the program: What made me make the jump from a Bachelor of Arts in Philosophy and Political Science to Ruby on Rails and JavaScript?

A few things.

1. A Love of Tinkering
I've loved technology since I was a kid. As a Girl Guide, age 9, I had every technology-related badge: completing the necessary steps usually involved begging my parents for a few old remotes and gadgets so I could take apart and reassemble them with my tiny fingers (and a screwdriver or two). At that age, there's nothing quite like splitting open a television remote to reveal the circuit board and copper "wires" etched into its surface.

I'm a curious person by nature, but I've always been particularly fascinated by technology. Tinkering can be a lot of fun, but it's also a fantastic way to learn about the world. The equal parts wonderful and terrifying sensation of breaking something apart, slowly gaining an understanding of its constituent elements and putting it back together with the newfound knowledge of how it ultimately works is something I experience daily as I learn to build things with Ruby on Rails. For a tinkerer, there is no greater satisfaction.

2. A Love of Making



3. Logic
Many are often surprised when I claim that coding and philosophy are more closely linked one would expect; I'm often surprised at the surprise that claim elicits. Coding, at its core, is the practice of writing sets of instructions. These instructions follow the logic of a particular programming language, such that, in Ruby:

*code snippet* code snippet = code snippet

In programming, until your code conforms to the specs that govern what constitutes an executable program, your code is 100% broken. In the world of philosophy, logical inference works in much the same way. To take a trivially simple example, if all A are B and all C are A, all C are therefore B. This argument is formally valid because it's true in all cases: C can't *occasionally* not be B. In a course I took on rational choice theory, for example, our assigned readings often looked like this:

*image of textbook*







Questions to answer:


1. What kind of person are you? Do you enjoy tinkering, breaking things? This seems to be important
	- self-regulating. No one in the program at this point (to my knowledge) is so out of their element that they feel inclined to throw in the towel.
	1. tinkerer - one thing I've heard several of my Bitmaker colleagues say to the point of cliche is that they're doing the assignment over again tonight because they want to know how x works, or what makes y tick. Programming is by definition about minutiae, about sweating the details: if you don't care to know why adding an @ symbol here breaks the entire page, or how .footer differs from #footer, you probably won't enjoy this kind of work.
	2. maker
	3. logical: I've spent the past five years studying philosophy, among other things.



3. Coding != Computer Science

Listening to David Heinemeier Hansson deliver the RailsConf keynote a little over two months ago was, for me, what Oprah might call an "aha" moment. It was exam season in my last semester of university and I had a few philosophy finals bearing down on me. As I began organizing my notes, I found a link on Twitter and fired up the RailsConf livestream. What began as white noise in the background quickly piqued my interest, and, soon enough, I found myself glued to the screen. Growing up in Copenhagen, DHH loved tinkering with computers and tried to learn programming on three separate occasions. In retrospect, his early, mostly uninspiring attempts at writing software had one important thing in common: each time he had tried and failed, Hansson encountered programming in the context of computer science. As a gamer and aspiring video game developer, some of his first attempts at programming were in the esoteric language AMOS Basic. There was plenty of math and physics involved and Hasson has the report cards to prove his lack of scientific aptitude: he was an F student in math and physics, but an A student in English. It was years later, at the age of 20, that Hansson finally learned to program. Three years after that, he invented Ruby on Rails. If your understanding of programming is based largely on the way it's depicted in popular culture, you may be wondering: how could that be?

Stories like Hansson's are inconvenient exceptions to many of the storied myths of programming: that what software engineers do is, in reality, a hard science akin to Linus Torvalds' development of the Linux kernel, and that in order to be a proficient programmer it's best to start parsing Ruby docs in pre-K. In reality, Hansson says, writing software is less like engineering and more like studying 17th century French poetry: when reading other people's programs, he says, most of his time is spent wondering "what the f--k did this guy mean?" Point taken—and now that I've waded through other people's code, I'd like to +1 that observation. In DHH's view, writing software boils down to precisely that: *writing*. While there will always be a place for unit testing, careful measurement and optimization, putting metrics and testing first is fundamentally wrongheaded because it sacrifices legibility and sound system design on the altar of objective science.

As a web dev-in-training, I prefer to look at the issue of testing and TDD with a bit more nuance (this is a great piece if you're interested in the other side of the story), but hearing DHH reject the computer science paradigm was yet another reminder that, as someone without a formal computer science education, programming is still very much "for me." This may seem like a simple realization, but as someone who loved studying the humanities and social sciences in university but still has a strong interest in software development, it was a relief to hear that the two aren't mutually exclusive, and—-in fact—-may be more directly related than previously imagined.




***
I'll be writing more about my experience at Bitmaker Labs in the weeks to come; feel free to get in touch if you have any questions. You should follow me on twitter at [@alessbell](http://www.twitter.com/alessbell).


<figure>
<a href="https://d262ilb51hltx0.cloudfront.net/max/800/1*7OzQX9jjmFXIUjnDhVCnjg.jpeg" title="The author's view at time of writing"><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*7OzQX9jjmFXIUjnDhVCnjg.jpeg" alt="The author's view at time of writing."></a><figcaption><a href="https://d262ilb51hltx0.cloudfront.net/max/800/1*7OzQX9jjmFXIUjnDhVCnjg.jpeg" title="The author's view at time of writing.">The author's view at time of writing.</a></figcaption>
</figure>